---
title: C++的类型缩窄转换
date: 2024-01-24 10:18:00+08:00
categories: [公众号, 编程]
tags: [C++, 编程, 类型转换, 技术, C++11]
slug: cpp-narrowing-conversion
---

<div class="p-3 text-center">
  <img class="img-fluid" src="/images/2024/0124/01.png" alt="题图" style="max-width:640px">
  <div><small>（题图由AI生成）</small></div>
</div>

在 C++ 编程中，数据类型转换是一个常见且重要的概念。这其中的一个特别的话题是 narrowing conversion，中文可译为缩窄转换（或窄化转换）。它发生在将一种数据类型转换为另一种较小的类型时（例如，将`double`类型转换为`int`，或将较大的整型转换为较小的整型），这类转换可能导致数据的精度损失或值的变化。

举例说明：

```cpp
int main() {
  double pi = 3.14159;
  int a = pi;  // 缩窄转换：从double到int

  long long large_number = 1234567890123;
  int b = large_number;  // 缩窄转换：从long long到int
}
```

在上述代码中，`pi` 到 `a` 的转换丢失了小数部分，而 `large_number` 到 `b` 的转换可能导致数值完全不同。

之所以发生变化，是因为对不同的数值类型，在计算机内部都有相应的表示方法，而受限于计算机底层实现，这些表示方法之间并不能完美“兼容”。

考虑下面的代码：

```cpp
int main() {
  unsigned char a = 200;
  char b = a;
  printf("b %s 0\n", (b >= 0 ? ">=" : "<"));
}
```

如果不能透彻理解各类数值在计算机内部的表示方法，是很难明白它为什么输出了 “`b < 0`” 而不是从语义上理解的 “`b >= 0`”。

上述代码中的 `char`，是 C++ 中的最小的整数类型，它是单词 character 的缩写，因为通常用它来表示单个字符（单个字节，也就是 8 个比特位），如果不对编译器做强制指定，一般它表示一个有符号的整数，也就是 `signed char`，取值范围从 `-128` 到 `127`，一共 256 种取值。而对于 unsigned char 类型，它占据的内存空间大小与 `signed char` 相同，都是单个字节，但表示范围就变成了从 `0` 到 `255`。这种表示范围的差异，就会导致数值类型转换之间的“不完美”。数值 `200` 超出了 `signed char` 能表示的范围，于是，即使 “`char b = a`” 这个语句只是做了单纯的一个字节的完整拷贝，但从后续的语义解释上，却把这个 `200` 解释成了负数。

更关键的是，为了“方便”程序员，上述代码并不会被编译器认为存在任何问题，甚至连警告都没有！这真是个代价巨大的历史包袱！缩窄转换与此类似，并且因为是使用更小的内存空间来保存原数值，因此问题更甚。但同样地，为了“方便”，过去都是被“宽容”地默许了的。

自 C++11 起，显然是在无数人被这种“便利”啃咬过以后，人们意识到了问题的严重性，所以从语言标准上做出了一定限制。在 C++11 中，列表初始化（用花括号 `{ }` ）不允许无警告的缩窄转换。例如：

```cpp
int x = 9.9;  // 允许，但会警告

int y{9.9};   // 错误：缩窄转换
```

这种严格检查能帮助开发者避免数据丢失相关的错误。但这些编译器警告设定和新语法规则，仍然不能完美解决所有问题。为了保持大量历史代码的兼容，同时又期望在编译期尽量发现问题，最终还是不得不做出某些权衡妥协。

那么，如何避免非期望的缩窄转换呢？

1. **显式类型转换**：在需要的地方使用`static_cast`或其他 C++ 类型转换，明确转换的意图。
2. **使用合适的数据类型**：在定义变量时，选择适当大小的数据类型。
3. **利用编译器警告**：利用编译器的警告信息来识别潜在的缩窄转换。
4. **代码审查**：定期进行代码审查，以识别和修正潜在的类型转换问题。

总之，理解并正确处理 narrowing conversion 对于写出安全、可靠的C++代码至关重要。C++的学习难度，就体现在这种“戴着镣铐跳舞”的自虐实践上，但也正是这样的“负重前行”，造就了 C++ 程序员无与伦比的战斗力和适应力。

类型转换是一个看起来简单，但使用起来往往复杂许多的概念。尤其是当它与类型重载、函数重载、模板特化等混杂起来，要在写 C++ 代码时，随时保持对代码的正确理解，并确保编译器会按照自己的期望来解析相应代码，就变得很有挑战。因而，这确实就是 C++ 编程的基本功所在。后续我也将继续探讨这方面的问题。

<div class="p-5 text-center">--- END ---</div>

<i><b>注：</b>本文首发表于[“不靠谱颜论”公众号](https://mp.weixin.qq.com/s/Gjfi8TC1Y6dfuj6AFVbV4A)，并同步至本站。</i>
