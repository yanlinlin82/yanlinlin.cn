---
title: 浮点数精度问题
date: 2009-06-30 19:03:00+08:00
place: 北京
tags: [编程, C++, 浮点数, 精度]
host-at: Oray
slug: floating-point-precision-issue
---
前段时间我就跟Jim讨论过这个，而今天在网上又看到有人在问，看来这浮点数精度问题，果然是可怜的二进制计算机界的永恒话题啊！

也许我们平时都不是特别注意，想当然地会认为精度问题离我们很遥远，其实不然：

    #include <iostream>

    int main()
    {
        std::cout << ".1 + .2 == .3" << std::endl;
        std::cout << (.1 + .2 == .3 ? "true" : "false") << std::endl;

        std::cout << "1e20 + 1000 == 1e20" << std::endl;
        std::cout << (1e20 + 1000 == 1e20 ? "true" : "false") << std::endl;

        return 0;
    }

这段程序的输出结果是：

    .1 + .2 == .3
    false
    1e20 + 1000 == 1e20
    true

很简单的加法，却是意外的结果吧？

其实原因很简单：计算机在浮点数时，小数部分也是用二进制的（0.5、0.25、0.125、……），所以十进制的很多浮点数都是没法精确表示的。虽然相比我们平常用的 double类型（64位），在CPU的内部会使用更高精度的寄存器（80位）来计算，一定程度上能够缓解精度表示问题，但是这并不能真正解决问题，尤其在比较浮点数相等时会比较明显。

所以，一旦使用了浮点数，一定要再三小心！
